save("C:\Users\Diag Davenport\Desktop\Edumacation, because degrees mean more than intelligence\Georgetown\CMP Process\From Darcy 20nov2016\Rio Negro Floods FULL.csv")
save("C:/Users\Diag Davenport\Desktop\Edumacation, because degrees mean more than intelligence\Georgetown\CMP Process\From Darcy 20nov2016\Rio Negro Floods FULL.csv")
save("C:/Users/Diag Davenport/Desktop/Edumacation, because degrees mean more than intelligence/Georgetown/CMP Process/From Darcy 20nov2016/Rio Negro Floods FULL.csv")
save("C:/Users/Diag Davenport/Desktop/Edumacation, because degrees mean more than intelligence/Georgetown/CMP Process/From Darcy 20nov2016/Rio Negro Floods FULL.csv")
sample(100)
x<-sample(10)
save(x)
devtools::use_data(x, mtcars)
use_data(x, mtcars)
install(devtools)
library(devtools)
install.packages(devtools)
install.packages("devtools")
library(devtools)
devtools::use_data(x, mtcars)
load("C:/Users/Diag Davenport/Desktop/cmpproc/data/mtcars.rda")
head(mtcars)
devtools::use_data(x)
devtools::use_data(x, overwrite = TRUE)
install.packages("compoisson")
install.packages('rmarkdown')
install.packages("rmarkdown")
data <- read.csv("/cenhome/morri410/cmpprocess/Rio Negro Floods FULL.csv",header=T)
data <- read.csv("data <- read.csv("C:/Users/Diag Davenport/Desktop/Edumacation, because degrees mean more than intelligence/Georgetown/CMP Process/From Darcy 20nov2016/Rio Negro Floods FULL.csv"",header=T)
data <- read.csv("data <- read.csv("C:\Users/Diag Davenport/Desktop/Edumacation, because degrees mean more than intelligence/Georgetown/CMP Process/From Darcy 20nov2016/Rio Negro Floods FULL.csv"",header=T)
data <- read.csv("data <- read.csv("C:\Users/Diag Davenport/Desktop/Edumacation, because degrees mean more than intelligence/Georgetown/CMP Process/From Darcy 20nov2016/Rio Negro Floods FULL.csv",header=T)
data <- read.csv("data <- read.csv("C:/Users/Diag Davenport/Desktop/Edumacation, because degrees mean more than intelligence/Georgetown/CMP Process/From Darcy 20nov2016/Rio Negro Floods FULL.csv",header=T)
data <- read.csv("C:/Users/Diag Davenport/Desktop/Edumacation, because degrees mean more than intelligence/Georgetown/CMP Process/From Darcy 20nov2016/Rio Negro Floods FULL.csv",header=T)
heax(data)
head(data)
CMPProcess()
data$Counts
data = data[is.na(data$Year)==0,]
data$Counts
CMPProcess <- function(counts)
{
LambdaNuPair <- function(par)
{
#print(c("this is par", par))
w <- 1
total <- 0
total <- sum(log(factorial(counts)))
#while(w <= length(counts))
#{
#print(w)
# total <- total + log(factorial(counts[w]))
#w <- w + 1
#}
-(log(par[1]) * sum(counts) - par[2] * total - length(counts) * com.compute.log.z(par[1],par[2],exp(-20)))
}
print("check1")
LambdaNuEst <- nlminb(start = c(1,1), LambdaNuPair, lower = c(exp(-10),exp(-10)), upper =c(Inf, Inf))
print("check")
# H <- -optimHess(LambdaNuEst$par, LambdaNuPair)
H <- hessian(LambdaNuPair, LambdaNuEst$par)
se <- sqrt(diag(solve(H)))
lambda <- LambdaNuEst$par[1]
nu <- LambdaNuEst$par[2]
Z <- com.compute.z(lambda,nu)
loglike <- -LambdaNuEst$objective
cat("log likelihood:",loglike,"\n")
cat("lambda:",lambda,"\n")
cat("nu:",nu,"\n")
cat("lambda se:",se[1],"\n")
cat("nu se:",se[2],"\n")
#cat("implied Z:",Z,"\n")
cat("real dispersion:", var(counts)/mean(counts),"\n")
#cat("implied dispersion:",com.var(lambda,nu)/com.mean(lambda,nu),"\n")
cat("waiting time distribution is geometric with parameter:", 1-1/Z,"\n")
cat("AIC:",4-2*loglike,"\n")
return(list(se=se, H=H, lambda=lambda, nu=nu, Z=Z, ll=loglike, aic=(4-2*loglike)))
}
CMPProcess(data$Counts)
install.packages("compoisson")
install.packages("numDeriv")
library(compoisson, numDeriv)
CMPProcess(data$Counts)
library(numDeriv)
CMPProcess(data$Counts)
CMPProcess(c(data$Counts, 20))
CMPProcess(c(data$Counts, 22000))
CMPProcess(c(data$Counts, 200))
CMPProcess(c(data$Counts, 20))
CMPProcess(c(data$Counts)
)
CMPProcess <- function(counts)
{
LambdaNuPair <- function(par)
{
#print(c("this is par", par))
w <- 1
total <- 0
system.time(total <- sum(log(factorial(counts))))
#while(w <= length(counts))
#{
#print(w)
# total <- total + log(factorial(counts[w]))
#w <- w + 1
#}
-(log(par[1]) * sum(counts) - par[2] * total - length(counts) * com.compute.log.z(par[1],par[2],exp(-20)))
}
print("check1")
LambdaNuEst <- nlminb(start = c(1,1), LambdaNuPair, lower = c(exp(-10),exp(-10)), upper =c(Inf, Inf))
print("check")
# H <- -optimHess(LambdaNuEst$par, LambdaNuPair)
H <- hessian(LambdaNuPair, LambdaNuEst$par)
se <- sqrt(diag(solve(H)))
lambda <- LambdaNuEst$par[1]
nu <- LambdaNuEst$par[2]
Z <- com.compute.z(lambda,nu)
loglike <- -LambdaNuEst$objective
cat("log likelihood:",loglike,"\n")
cat("lambda:",lambda,"\n")
cat("nu:",nu,"\n")
cat("lambda se:",se[1],"\n")
cat("nu se:",se[2],"\n")
#cat("implied Z:",Z,"\n")
cat("real dispersion:", var(counts)/mean(counts),"\n")
#cat("implied dispersion:",com.var(lambda,nu)/com.mean(lambda,nu),"\n")
cat("waiting time distribution is geometric with parameter:", 1-1/Z,"\n")
cat("AIC:",4-2*loglike,"\n")
return(list(se=se, H=H, lambda=lambda, nu=nu, Z=Z, ll=loglike, aic=(4-2*loglike)))
}
CMPProcess(c(data$Counts))
CMPProcess <- function(counts)
{
LambdaNuPair <- function(par)
{
#print(c("this is par", par))
w <- 1
total <- 0
total <- sum(log(factorial(counts)))
#while(w <= length(counts))
#{
#print(w)
# total <- total + log(factorial(counts[w]))
#w <- w + 1
#}
-(log(par[1]) * sum(counts) - par[2] * total - length(counts) * com.compute.log.z(par[1],par[2],exp(-20)))
}
print("check1")
LambdaNuEst <- nlminb(start = c(1,1), LambdaNuPair, lower = c(exp(-10),exp(-10)), upper =c(Inf, Inf))
print("check")
# H <- -optimHess(LambdaNuEst$par, LambdaNuPair)
H <- hessian(LambdaNuPair, LambdaNuEst$par)
se <- sqrt(diag(solve(H)))
lambda <- LambdaNuEst$par[1]
nu <- LambdaNuEst$par[2]
Z <- com.compute.z(lambda,nu)
loglike <- -LambdaNuEst$objective
cat("log likelihood:",loglike,"\n")
cat("lambda:",lambda,"\n")
cat("nu:",nu,"\n")
cat("lambda se:",se[1],"\n")
cat("nu se:",se[2],"\n")
#cat("implied Z:",Z,"\n")
cat("real dispersion:", var(counts)/mean(counts),"\n")
#cat("implied dispersion:",com.var(lambda,nu)/com.mean(lambda,nu),"\n")
cat("waiting time distribution is geometric with parameter:", 1-1/Z,"\n")
cat("AIC:",4-2*loglike,"\n")
return(list(se=se, H=H, lambda=lambda, nu=nu, Z=Z, ll=loglike, aic=(4-2*loglike)))
}
CMPProcess(c(data$Counts))
proc.time
proc.time()
proc.time()
proc.time()
print(proc.time())
CMPProcess <- function(counts)
{
LambdaNuPair <- function(par)
{
w <- 1
total <- 0
print(proc.time())
total <- sum(log(factorial(counts)))
print(proc.time())
print(proc.time())
while(w <= length(counts))
{
print(w)
total <- total + log(factorial(counts[w]))
w <- w + 1
}
print(proc.time())
-(log(par[1]) * sum(counts) - par[2] * total - length(counts) * com.compute.log.z(par[1],par[2],exp(-20)))
}
print("check1")
LambdaNuEst <- nlminb(start = c(1,1), LambdaNuPair, lower = c(exp(-10),exp(-10)), upper =c(Inf, Inf))
print("check")
# H <- -optimHess(LambdaNuEst$par, LambdaNuPair)
H <- hessian(LambdaNuPair, LambdaNuEst$par)
se <- sqrt(diag(solve(H)))
lambda <- LambdaNuEst$par[1]
nu <- LambdaNuEst$par[2]
Z <- com.compute.z(lambda,nu)
loglike <- -LambdaNuEst$objective
cat("log likelihood:",loglike,"\n")
cat("lambda:",lambda,"\n")
cat("nu:",nu,"\n")
cat("lambda se:",se[1],"\n")
cat("nu se:",se[2],"\n")
#cat("implied Z:",Z,"\n")
cat("real dispersion:", var(counts)/mean(counts),"\n")
#cat("implied dispersion:",com.var(lambda,nu)/com.mean(lambda,nu),"\n")
cat("waiting time distribution is geometric with parameter:", 1-1/Z,"\n")
cat("AIC:",4-2*loglike,"\n")
return(list(se=se, H=H, lambda=lambda, nu=nu, Z=Z, ll=loglike, aic=(4-2*loglike)))
}
CMPProcess(c(data$Counts))
CMPProcess <- function(counts)
{
LambdaNuPair <- function(par)
{
w <- 1
total <- 0
print(proc.time())
total <- sum(log(factorial(counts)))
print(proc.time())
print(proc.time())
while(w <= length(counts))
{
total <- total + log(factorial(counts[w]))
w <- w + 1
}
print(proc.time())
-(log(par[1]) * sum(counts) - par[2] * total - length(counts) * com.compute.log.z(par[1],par[2],exp(-20)))
}
print("check1")
LambdaNuEst <- nlminb(start = c(1,1), LambdaNuPair, lower = c(exp(-10),exp(-10)), upper =c(Inf, Inf))
print("check")
# H <- -optimHess(LambdaNuEst$par, LambdaNuPair)
H <- hessian(LambdaNuPair, LambdaNuEst$par)
se <- sqrt(diag(solve(H)))
lambda <- LambdaNuEst$par[1]
nu <- LambdaNuEst$par[2]
Z <- com.compute.z(lambda,nu)
loglike <- -LambdaNuEst$objective
cat("log likelihood:",loglike,"\n")
cat("lambda:",lambda,"\n")
cat("nu:",nu,"\n")
cat("lambda se:",se[1],"\n")
cat("nu se:",se[2],"\n")
#cat("implied Z:",Z,"\n")
cat("real dispersion:", var(counts)/mean(counts),"\n")
#cat("implied dispersion:",com.var(lambda,nu)/com.mean(lambda,nu),"\n")
cat("waiting time distribution is geometric with parameter:", 1-1/Z,"\n")
cat("AIC:",4-2*loglike,"\n")
return(list(se=se, H=H, lambda=lambda, nu=nu, Z=Z, ll=loglike, aic=(4-2*loglike)))
}
CMPProcess(c(data$Counts))
_Go on to describe each method or focus in on one?_
